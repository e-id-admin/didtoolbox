
use crate::ed25519::{Ed25519VerifyingKey};

#[derive(Clone)]
pub enum CryptoSuiteType {
    Bbs2023,
    EcdsaRdfc2019,
    EcdsaJcs2019,
    EcdsaSd2019,
    EddsaRdfc2022,
    EddsaJcs2022
}

impl std::fmt::Display for CryptoSuiteType {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        let string_representation = match self {
            CryptoSuiteType::Bbs2023 => String::from("bbs-2023"),
            CryptoSuiteType::EcdsaRdfc2019 => String::from("ecdsa-rdfc-2019"),
            CryptoSuiteType::EcdsaJcs2019 => String::from("ecdsa-jcs-2019"),
            CryptoSuiteType::EcdsaSd2019 => String::from("ecdsa-sd-2019"),
            CryptoSuiteType::EddsaRdfc2022 => String::from("eddsa-rdfc-2022"),
            CryptoSuiteType::EddsaJcs2022 => String::from("eddsa-jcs-2022"),
        };
        write!(f, "{}", string_representation)
    }
}

#[derive(Clone)]
pub struct CryptoSuiteOptions {
    pub proof_type: String,
    pub crypto_suite: CryptoSuiteType,
    pub verification_method: String,
    pub proof_purpose: String,
    pub challenge: Option<String>,
}

impl CryptoSuiteOptions {
    pub fn new(crypto_suite: CryptoSuiteType, verification_method: String, challenge: String) -> CryptoSuiteOptions {
        CryptoSuiteOptions {
            proof_type: "DataIntegrityProof".to_string(),
            crypto_suite,
            verification_method,
            proof_purpose: "authentication".to_string(),
            challenge: Some(challenge),
        }
    }
}

/// Output generated by the verifyProof algorithm as defined in the vc-data-integrity algorithm
/// https://www.w3.org/TR/vc-data-integrity/#dfn-verifyproof
pub struct CryptoSuiteVerificationResult {
    pub verified: bool,
    pub verified_document: String,
    pub errors: Vec<String>,
}

pub trait CryptoSuite {
    fn create_proof(&self, unsecured_data_document: &serde_json::Value, proof_options: &CryptoSuiteOptions) -> String;
    //fn create_verification(&self, secured_document: &str, presentation_header: String) -> CryptoSuiteVerificationResult;
}

/// Is main entry point for proof generation and validation of a given verifiable credential
/// Function in this class are based on algorithm section in the vc-dat-integrity spec
/// https://www.w3.org/TR/vc-data-integrity/#algorithms
pub trait VCDataIntegrity {
    fn add_proof(&self, unsecured_document: &serde_json::Value, options: &CryptoSuiteOptions) -> serde_json::Value;
    fn verify_proof(&self, secured_document: &serde_json::Value, presentation_header: String, public_key: &Ed25519VerifyingKey) -> CryptoSuiteVerificationResult;
}