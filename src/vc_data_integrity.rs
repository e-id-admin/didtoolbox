// SPDX-License-Identifier: MIT
use crate::ed25519::*;
use crate::utils::{DATE_TIME_FORMAT};
use crate::didtoolbox::*;
use serde_jcs::{to_vec as jcs_from_str, to_string as jcs_to_string};
use chrono::{serde::ts_seconds, DateTime, Utc};
use serde::{Deserialize, Serialize};
use sha2::{Sha256, Digest};
use serde_json::json;
use serde_json::Value::String as JsonString;
use hex;
use hex::ToHex;

#[derive(Clone)]
pub enum CryptoSuiteType {
    Bbs2023,
    EcdsaRdfc2019,
    EcdsaJcs2019,
    EcdsaSd2019,
    EddsaRdfc2022,
    EddsaJcs2022
}

impl std::fmt::Display for CryptoSuiteType {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        let string_representation = match self {
            CryptoSuiteType::Bbs2023 => String::from("bbs-2023"),
            CryptoSuiteType::EcdsaRdfc2019 => String::from("ecdsa-rdfc-2019"),
            CryptoSuiteType::EcdsaJcs2019 => String::from("ecdsa-jcs-2019"),
            CryptoSuiteType::EcdsaSd2019 => String::from("ecdsa-sd-2019"),
            CryptoSuiteType::EddsaRdfc2022 => String::from("eddsa-rdfc-2022"),
            CryptoSuiteType::EddsaJcs2022 => String::from("eddsa-jcs-2022"),
        };
        write!(f, "{}", string_representation)
    }
}

#[derive(Clone)]
pub struct CryptoSuiteOptions {
    pub proof_type: String,
    pub crypto_suite: CryptoSuiteType,
    pub verification_method: String,
    pub proof_purpose: String,
    pub challenge: Option<String>,
}

impl CryptoSuiteOptions {
    pub fn new(crypto_suite: CryptoSuiteType, verification_method: String, challenge: String) -> CryptoSuiteOptions {
        CryptoSuiteOptions {
            proof_type: "DataIntegrityProof".to_string(),
            crypto_suite,
            verification_method,
            proof_purpose: "authentication".to_string(),
            challenge: Some(challenge),
        }
    }
}
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct DataIntegrityProof {
    #[serde(rename = "type")]
    pub proof_type: String,
    #[serde(rename = "cryptoSuite")]
    pub crypto_suite: String,
    #[serde(with = "ts_seconds")]
    pub created: DateTime<Utc>,
    #[serde(rename = "verificationMethod")]
    pub verification_method: String,
    #[serde(rename = "proofPurpose")]
    pub proof_purpose: String,
    pub challenge: String,
    #[serde(rename = "proofValue")]
    pub proof_value: String,
}
impl DataIntegrityProof {
    pub fn from(json: String) -> Self {
        let value: serde_json::Value = serde_json::from_str(&json).unwrap();
        DataIntegrityProof {
            proof_type: match value["type"] {
                serde_json::Value::String(ref s) => s.to_string(),
                _ => String::from(""),
            },
            crypto_suite: match value["cryptoSuite"] {
                serde_json::Value::String(ref s) => s.to_string(),
                _ => String::from(""),
            },
            created: match value["created"] {
                serde_json::Value::String(ref s) => DateTime::parse_from_str(s, DATE_TIME_FORMAT).unwrap().to_utc(),
                _ => Utc::now(),
            },
            verification_method: match value["verificationMethod"] {
                serde_json::Value::String(ref s) => s.to_string(),
                _ => String::from(""),
            },
            proof_purpose: match value["proofPurpose"] {
                serde_json::Value::String(ref s) => s.to_string(),
                _ => String::from(""),
            },
            challenge: match value["challenge"] {
                serde_json::Value::String(ref s) => s.to_string(),
                _ => String::from("")
            },
            proof_value: match value["proofValue"] {
                serde_json::Value::String(ref s) => s.to_string(),
                _ => String::from(""),
            },
        }
    }

    pub fn to_value(&self) -> serde_json::Value {
        let mut value = serde_json::to_value(&self).unwrap();
        value["created"] = serde_json::Value::String(self.created.format(DATE_TIME_FORMAT).to_string());
        value
    }
}

/// Output generated by the verifyProof algorithm as defined in the vc-data-integrity algorithm
/// https://www.w3.org/TR/vc-data-integrity/#dfn-verifyproof
pub struct CryptoSuiteVerificationResult {
    pub verified: bool,
    pub verified_document: String,
    pub errors: Vec<String>,
}

pub trait CryptoSuite {
    fn create_proof(&self, unsecured_data_document: &serde_json::Value, proof_options: &CryptoSuiteOptions) -> String;
    //fn create_verification(&self, secured_document: &str, presentation_header: String) -> CryptoSuiteVerificationResult;
}

/// Is main entry point for proof generation and validation of a given verifiable credential
/// Function in this class are based on algorithm section in the vc-dat-integrity spec
/// https://www.w3.org/TR/vc-data-integrity/#algorithms
pub trait VCDataIntegrity {
    fn add_proof(&self, unsecured_document: &serde_json::Value, options: &CryptoSuiteOptions) -> serde_json::Value;
    fn verify_proof(&self, secured_document: &serde_json::Value) -> bool;
}

pub struct EddsaCryptosuite {
    pub verifying_key: Option<Ed25519VerifyingKey>,
    pub signing_key: Option<Ed25519SigningKey>,
}

fn generate_jcs_hash_from_value(value: &serde_json::Value) -> String {
    let json_doc = value.to_string();
    let jcs_doc = jcs_from_str(&json_doc).unwrap();
    let utf8_doc: String = String::from_utf8(jcs_doc).unwrap();
    let mut doc_hasher = Sha256::new();
    doc_hasher.update(utf8_doc);
    doc_hasher.finalize().encode_hex()
}


impl VCDataIntegrity for EddsaCryptosuite {
    fn add_proof(&self, unsecured_document: &serde_json::Value, options: &CryptoSuiteOptions) -> serde_json::Value {
        if !matches!(options.crypto_suite, CryptoSuiteType::EddsaJcs2022) {
            panic!("Invalid crypto suite. Only eddsa-jcs-2022 is supported");
        }
        if options.proof_type != "DataIntegrityProof" {
            panic!("Invalid proof type. Only DataIntegrityProof is supported");
        }

        // 3.1.3 Transformation of doc and options
        let mut proof = json!({
            "type": options.proof_type,
            "cryptoSuite": options.crypto_suite.to_string(),
            "created": Utc::now().format(DATE_TIME_FORMAT).to_string(),
            "verificationMethod": options.verification_method,
            "proofPurpose": options.proof_purpose,
            "challenge": options.challenge.as_ref().unwrap(),
        });
        // 3.1.4 Hash didDoc and config
        let proof_hash = generate_jcs_hash_from_value(&proof);
        let doc_hash = generate_jcs_hash_from_value(unsecured_document);
        let hash_data = proof_hash + &doc_hash;

        // 3.1.6 Proof serialization
        let proof_signature = match &self.signing_key {
            Some(signing_key) => {
                signing_key.sign(hash_data)
            },
            None => panic!("Invalid eddsa cryptosuite. Signing key is missing but required for proof creation"),
        };
        let proof_signature_multibase = proof_signature.to_multibase();
        proof["proofValue"] = JsonString(proof_signature_multibase);

        // Create secured document
        let mut secured_document = unsecured_document.clone();
        secured_document["proof"] = proof;
        secured_document

    }

    fn verify_proof(&self, secured_document: &serde_json::Value) -> bool {
        let original_proof = secured_document["proof"].clone();
        let mut proof = json!({
            "type": original_proof["type"],
            "cryptoSuite": original_proof["cryptoSuite"],
            "created": original_proof["created"],
            "verificationMethod": original_proof["verificationMethod"],
            "proofPurpose": original_proof["proofPurpose"],
            "challenge": original_proof["challenge"],
        });

        let doc: DidDoc = serde_json::from_value(secured_document.clone()).unwrap();
        let proof_hash = generate_jcs_hash_from_value(&proof);
        let doc_hash = generate_jcs_hash_from_value(&serde_json::to_value(&doc).unwrap());
        let hash_data = proof_hash + &doc_hash;

        let signature = match secured_document["proof"]["proofValue"] {
            JsonString(ref proof_value) => {
                Ed25519Signature::from_multibase(proof_value)
            },
            _ => panic!("Invalid proof value. Expected string"),
        };
        match self.verifying_key {
            Some(ref verifying_key) => {
                match verifying_key.verifying_key.verify_strict(hash_data.as_bytes(), &signature.signature) {
                    Ok(_) => true,
                    Err(_) => false,
                }
            },
            None => panic!("Invalid eddsa cryptosuite. Verifying key is missing but required for proof verification"),
        }
    }
}
